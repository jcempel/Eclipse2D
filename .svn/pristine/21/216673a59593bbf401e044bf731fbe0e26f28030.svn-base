using System;
using System.Windows.Forms;
using SharpDX;
using SharpDX.Direct2D1;
using SharpDX.Direct3D;
using SharpDX.Direct3D11;
using SharpDX.DXGI;
using SharpDX.IO;
using SharpDX.WIC;
using SharpDX.Windows;

namespace Eclipse2D.Graphics
{
    public class GraphicsDevice
    {
        /// <summary>
        /// Represents the render form that acts as the game window.
        /// </summary>
        private SharpDX.Windows.RenderForm m_RenderForm;

        /// <summary>
        /// Represents the Direct3D 11 device, which creates Direct3D 11 objects.
        /// </summary>
        private SharpDX.Direct3D11.Device m_D3D11Device;

        /// <summary>
        /// Represents the Direct3D 11 device context, which generates rendering commands.
        /// </summary>
        private SharpDX.Direct3D11.DeviceContext m_D3D11DeviceContext;

        /// <summary>
        /// Represents the feature level that Direct3D is targetting.
        /// </summary>
        private SharpDX.Direct3D.FeatureLevel m_FeatureLevel;

        /// <summary>
        /// Represents the DXGI device, which created the Direct3D device and the virtual video adapter.
        /// </summary>
        private SharpDX.DXGI.Device m_DXGIDevice;

        /// <summary>
        /// Represents the DXGI adapter, which is a virtual representation of the video card.
        /// </summary>
        private SharpDX.DXGI.Adapter m_DXGIAdapter;

        /// <summary>
        /// Represents the DXGI factory, which creates the swap chain.
        /// </summary>
        private SharpDX.DXGI.Factory2 m_DXGIFactory;

        /// <summary>
        /// Represents the DXGI swap chain, which is how Direct3D renders to the monitor.
        /// </summary>
        private SharpDX.DXGI.SwapChain1 m_DXGISwapChain;

        /// <summary>
        /// Represents the DXGI surface, which is the back buffer for the Direct3D swap chain.
        /// </summary>
        private SharpDX.DXGI.Surface m_DXGISurface;

        /// <summary>
        /// Represents the Direct2D device, which creates Direct2D objects.
        /// </summary>
        private SharpDX.Direct2D1.Device m_D2D1Device;

        /// <summary>
        /// Represents the Direct2D device context, which generates rendering commands.
        /// </summary>
        private SharpDX.Direct2D1.DeviceContext m_D2D1DeviceContext;

        /// <summary>
        /// Represents the Direct2D render target, which is shared with the DXGI surface back buffer.
        /// </summary>
        private SharpDX.Direct2D1.Bitmap1 m_D2DRenderTarget;

        // Test purposes.
        private SharpDX.Direct2D1.Bitmap1 m_PlayerBitmap;
        private SharpDX.Direct2D1.Bitmap1 m_TerrainBitmap;
        private SharpDX.Direct2D1.BitmapBrush1 m_TerrainBrush;

        private Single AlphaTest;
        private Single RotationTest;

        /// <summary>
        /// Represents the windowed resolution when returning from full screen mode.
        /// </summary>
        private System.Drawing.Size m_Resolution;

        /// <summary>
        /// Initializes a new GraphicsDevice with the specified render form.
        /// </summary>
        /// <param name="RenderWindow">The render form associated with this graphics device.</param>
        public GraphicsDevice(RenderForm RenderWindow)
        {
            Initialize(RenderWindow);
        }

        /// <summary>
        /// Initializes the rendering engine.
        /// </summary>
        /// <param name="RenderWindow">The render form associated with this graphics device.</param>
        private void Initialize(RenderForm RenderWindow)
        {
            // Set the game window.
            m_RenderForm = RenderWindow;

            // Set the resolution.
            m_Resolution = m_RenderForm.ClientSize;

            // Initialize the feature levels.
            SharpDX.Direct3D.FeatureLevel[] FeatureLevels = new SharpDX.Direct3D.FeatureLevel[]
            {
                SharpDX.Direct3D.FeatureLevel.Level_11_1,
                SharpDX.Direct3D.FeatureLevel.Level_11_0,
                SharpDX.Direct3D.FeatureLevel.Level_10_1,
                SharpDX.Direct3D.FeatureLevel.Level_10_0,
                SharpDX.Direct3D.FeatureLevel.Level_9_3,
                SharpDX.Direct3D.FeatureLevel.Level_9_2,
                SharpDX.Direct3D.FeatureLevel.Level_9_1
            };

            // Initialize the Direct3D11 device with BGRA support for Direct2D.
            m_D3D11Device = new SharpDX.Direct3D11.Device(DriverType.Hardware, DeviceCreationFlags.BgraSupport, FeatureLevels);

            // Get the device context.
            m_D3D11DeviceContext = m_D3D11Device.ImmediateContext;

            // Get the device feature level.
            m_FeatureLevel = m_D3D11Device.FeatureLevel;

            // Get the underlying DXGI device of the Direct3D11 device.
            m_DXGIDevice = m_D3D11Device.QueryInterface<SharpDX.DXGI.Device>();

            // Initialize the Direct2D1 device.
            m_D2D1Device = new SharpDX.Direct2D1.Device(m_DXGIDevice);

            // Initialize the Direct2D1 device context.
            m_D2D1DeviceContext = new SharpDX.Direct2D1.DeviceContext(m_D2D1Device, DeviceContextOptions.None);

            // Initialize the DXGI swap chain.
            SharpDX.DXGI.SwapChainDescription1 SwapChainDesc = new SwapChainDescription1()
            {
                // Automatic sizing for the width of the window.
                Width = 0,

                // Automatic sizing for the height of the window.
                Height = 0,

                // Allows the swap chain to be compatible with Direct2D.
                Format = SharpDX.DXGI.Format.B8G8R8A8_UNorm,

                // Disable multi-sampling.
                SampleDescription = new SampleDescription(1, 0),

                // Allows rendering on the back buffer.
                Usage = Usage.RenderTargetOutput,

                // Allows double-buffering.
                BufferCount = 2,

                // Discards the back buffer contents after each Present.
                SwapEffect = SwapEffect.Discard,

                // Allows window transitions.
                Flags = SwapChainFlags.AllowModeSwitch
            };

            // Identifies the physical adapter this device runs on.
            m_DXGIAdapter = m_DXGIDevice.Adapter;

            // Get the factory object that created the DXGI device.
            m_DXGIFactory = m_DXGIAdapter.GetParent<SharpDX.DXGI.Factory2>();

            // Initialize the swap chain from the DXGI factory.
            m_DXGISwapChain = new SwapChain1(m_DXGIFactory, m_D3D11Device, m_RenderForm.Handle, ref SwapChainDesc);

            // Initialize the bitmap properties. This configures the bitmap linked to the swap chain.
            // Rendering to this bitmap directly renders to the swap chain.
            SharpDX.Direct2D1.BitmapProperties1 BitmapProperties = new SharpDX.Direct2D1.BitmapProperties1()
            {
                // Sets the bitmap up to be used as a render target.
                BitmapOptions = BitmapOptions.Target | BitmapOptions.CannotDraw,

                // Configure the pixel format to be compatible with Direct2D1.
                PixelFormat = new SharpDX.Direct2D1.PixelFormat(Format.B8G8R8A8_UNorm, SharpDX.Direct2D1.AlphaMode.Ignore),

                // Gets the DPI width used by the monitor.
                DpiX = m_D2D1DeviceContext.DotsPerInch.Width,

                // Gets the DPI height used by the monitor.
                DpiY = m_D2D1DeviceContext.DotsPerInch.Height
            };

            // Direct2D1 needs the version of the DXGI back buffer surface pointer.
            m_DXGISurface = m_DXGISwapChain.GetBackBuffer<SharpDX.DXGI.Surface>(0);

            // Initialize the Direct2D1 render target.
            m_D2DRenderTarget = new SharpDX.Direct2D1.Bitmap1(m_D2D1DeviceContext, m_DXGISurface, BitmapProperties);

            // Set the render target on the Direct2D1 device context.
            m_D2D1DeviceContext.Target = m_D2DRenderTarget;

            // Load an actor "player" bitmap.
            m_PlayerBitmap = LoadBitmapFromFile("/Assets/Bitmaps/player.png");

            // Load a terrain bitmap.
            m_TerrainBitmap = LoadBitmapFromFile("/Assets/Bitmaps/terrain.png");

            // Initialize 
            m_TerrainBrush = new BitmapBrush1(m_D2D1DeviceContext, m_TerrainBitmap, new BitmapBrushProperties1()
            {
                ExtendModeX = ExtendMode.Wrap,
                ExtendModeY = ExtendMode.Wrap
            });
        }

        /// <summary>
        /// Sets the screen state of the game window.
        /// </summary>
        /// <param name="IsFullScreen">Determines if the screen state of the game window is full-screen or windowed.</param>
        public void SetFullscreenState(Boolean IsFullScreen)
        {
            // Prepares the game window to become full-screen. Setting this alone doesn't change the game
            // window to full-screen, but it disables window features that can't be used in full-screen.
            m_RenderForm.IsFullscreen = IsFullScreen;

            // Sets the screen state to full-screen using the current windowed resolution.
            m_DXGISwapChain.SetFullscreenState(IsFullScreen, null);

            // Check if we're returning to windowed mode.
            if (!m_RenderForm.IsFullscreen)
            {
                // Change the resolution back to the last windowed-mode resolution.
                // TODO: Make this a global variable to keep track of the last known resolution.
                SetResolution(1024, 768);
            }
        }

        /// <summary>
        /// Gets the screen state of the game window.
        /// </summary>
        /// <returns></returns>
        public Boolean GetFullscreenState()
        {
            return m_RenderForm.IsFullscreen;
        }

        /// <summary>
        /// Sets the game window resolution to the specified width and height.
        /// </summary>
        /// <param name="Width">The width of the game window.</param>
        /// <param name="Height">The height of the game window.</param>
        public void SetResolution(Int32 Width, Int32 Height)
        {
            SetResolution(new System.Drawing.Size(Width, Height));
        }

        /// <summary>
        /// Sets the game window resolution to the specified size.
        /// </summary>
        /// <param name="Resolution">The size (width and height) of the game window.</param>
        public void SetResolution(System.Drawing.Size Resolution)
        {
            // Set the new resolution.
            m_Resolution = Resolution;

            // Check if we're in windowed mode.
            if (!m_RenderForm.IsFullscreen)
            {
                // Set the new resolution on the game window.
                m_RenderForm.ClientSize = m_Resolution;
            }

            // Dispose any device-dependent resources.
            DisposeResources();

            // Resize the back buffers.
            m_DXGISwapChain.ResizeBuffers(0, m_Resolution.Width, m_Resolution.Height, Format.B8G8R8A8_UNorm, SwapChainFlags.AllowModeSwitch);

            // Resize the swap chain buffers to set the fullscreen resolution.
            ModeDescription TargetDescription = new ModeDescription()
            {
                Width = m_Resolution.Width,
                Height = m_Resolution.Height,
                RefreshRate = new Rational(60, 1),
                Format = Format.B8G8R8A8_UNorm
            };

            // Resize the output target.
            m_DXGISwapChain.ResizeTarget(ref TargetDescription);

            // Reload any device-dependent resources.
            ReloadResources();
        }

        /// <summary>
        /// Gets the resolution of the game window.
        /// </summary>
        /// <returns></returns>
        public System.Drawing.Size GetResolution()
        {
            return m_Resolution;
        }

        private void DisposeResources()
        {
            // Dispose existing objects.
            m_D2D1DeviceContext.Target = null;
            Utilities.Dispose(ref m_TerrainBitmap);
            Utilities.Dispose(ref m_TerrainBrush);
            Utilities.Dispose(ref m_PlayerBitmap);
            Utilities.Dispose(ref m_D2DRenderTarget);
            Utilities.Dispose(ref m_DXGISurface);
        }

        private void ReloadResources()
        {
            // Initialize the bitmap properties. This configures the bitmap linked to the swap chain.
            // Rendering to this bitmap directly renders to the swap chain.
            SharpDX.Direct2D1.BitmapProperties1 BitmapProperties = new SharpDX.Direct2D1.BitmapProperties1()
            {
                // Sets the bitmap up to be used as a render target.
                BitmapOptions = BitmapOptions.Target | BitmapOptions.CannotDraw,

                // Configure the pixel format to be compatible with Direct2D1.
                PixelFormat = new SharpDX.Direct2D1.PixelFormat(Format.B8G8R8A8_UNorm, SharpDX.Direct2D1.AlphaMode.Ignore),

                // Gets the DPI width used by the monitor.
                DpiX = m_D2D1DeviceContext.DotsPerInch.Width,

                // Gets the DPI height used by the monitor.
                DpiY = m_D2D1DeviceContext.DotsPerInch.Height
            };

            // Direct2D1 needs the version of the DXGI back buffer surface pointer.
            m_DXGISurface = m_DXGISwapChain.GetBackBuffer<SharpDX.DXGI.Surface>(0);

            // Initialize the Direct2D1 render target.
            m_D2DRenderTarget = new SharpDX.Direct2D1.Bitmap1(m_D2D1DeviceContext, m_DXGISurface, BitmapProperties);

            m_D2D1DeviceContext.Target = m_D2DRenderTarget;

            // Load an actor "player" bitmap.
            m_PlayerBitmap = LoadBitmapFromFile("/Assets/Bitmaps/player.png");

            // Load a terrain bitmap.
            m_TerrainBitmap = LoadBitmapFromFile("/Assets/Bitmaps/terrain.png");

            // Initialize 
            m_TerrainBrush = new BitmapBrush1(m_D2D1DeviceContext, m_TerrainBitmap, new BitmapBrushProperties1()
            {
                ExtendModeX = ExtendMode.Wrap,
                ExtendModeY = ExtendMode.Wrap
            });
        }

        /// <summary>
        /// Sets the render target associated with the device context.
        /// </summary>
        /// <param name="RenderTarget">The render target to use with the device context.</param>
        public void SetRenderTarget(Image RenderTarget)
        {
            m_D2D1DeviceContext.Target = RenderTarget;
        }

        /// <summary>
        /// Sets/Gets the transformation matrix associated with the device context.
        /// </summary>
        /// <param name="Transform">The transformation matrix</param>
        public Matrix3x2 Transform
        {
            set
            {
                m_D2D1DeviceContext.Transform = value;
            }

            get
            {
                return m_D2D1DeviceContext.Transform;
            }
        }

        /// <summary>
        /// Clears the back buffer to the specified color.
        /// </summary>
        /// <param name="ClearColor">The color to clear the back buffer.</param>
        public void Clear(Color ClearColor)
        {
            m_D2D1DeviceContext.Clear(ClearColor);
        }

        /// <summary>
        /// Begins the drawing sequence for the render target.
        /// </summary>
        public void BeginDraw()
        {
            m_D2D1DeviceContext.BeginDraw();
        }

        /// <summary>
        /// Ends the drawing sequence for the render target.
        /// </summary>
        public void EndDraw()
        {
            m_D2D1DeviceContext.EndDraw();
        }

        /// <summary>
        /// Presents the rendered image.
        /// </summary>
        public void Present()
        {
            Present(1);
        }

        /// <summary>
        /// Presents the rendered image with the specified sync interval.
        /// </summary>
        /// <param name="SyncInterval">The interval between each verticle blank.</param>
        public void Present(Int32 SyncInterval)
        {
            m_DXGISwapChain.Present(SyncInterval, PresentFlags.None);
        }

        /// <summary>
        /// Presents the rendered image with the specified sync interval and presentation flags.
        /// </summary>
        /// <param name="SyncInterval">The interval between each verticle blank.</param>
        /// <param name="Flags">The presentation flags to use.</param>
        public void Present(Int32 SyncInterval, PresentFlags Flags)
        {
            m_DXGISwapChain.Present(SyncInterval, Flags);
        }

        /// <summary>
        /// Draws the bitmap to the render target with the specified opacity.
        /// </summary>
        /// <param name="Bitmap">The bitmap to draw to the render target.</param>
        /// <param name="Opacity">The opacity to apply to the bitmap.</param>
        /// <dev-note>Test method until the Texture2D is fully-functional.</dev-note>
        public void DrawBitmap(Bitmap1 Bitmap, Single Opacity)
        {
            m_D2D1DeviceContext.DrawBitmap(Bitmap, Opacity, SharpDX.Direct2D1.InterpolationMode.Linear);
        }

        /// <summary>
        /// Draws the texture to the render target with the specified opacity.
        /// </summary>
        /// <param name="Texture">The texture to draw to the render target.</param>
        /// <param name="Opacity">The opacity to apply to the texture.</param>
        public void DrawTexture2D(Texture2D Texture, Single Opacity)
        {
            m_D2D1DeviceContext.DrawBitmap(Texture.Bitmap, Opacity, SharpDX.Direct2D1.InterpolationMode.Linear);
        }

        /// <summary>
        /// Draws the texture to the render target with the specified destination rectangle and opacity.
        /// </summary>
        /// <param name="Texture">The texture to draw to the render target.</param>
        /// <param name="DestinationRectangle">The destination rectangle for the texture.</param>
        /// <param name="Opacity">The opacity to apply to the texture.</param>
        public void DrawTexture2D(Texture2D Texture, RectangleF DestinationRectangle, Single Opacity)
        {
            m_D2D1DeviceContext.DrawBitmap(Texture.Bitmap, DestinationRectangle, Opacity, SharpDX.Direct2D1.BitmapInterpolationMode.Linear);
        }

        /// <summary>
        /// Draws the texture to the render target with the specified destination rectangle and opacity.
        /// </summary>
        /// <param name="Texture">The texture to draw to the render target.</param>
        /// <param name="DestinationRectangle">The destination rectangle for the texture.</param>
        /// <param name="SourceRectangle">The source rectangle for the texture.</param>
        /// <param name="Opacity">The opacity to apply to the texture.</param>
        public void DrawTexture(Texture2D Texture, RectangleF DestinationRectangle, RectangleF SourceRectangle, Single Opacity)
        {
            m_D2D1DeviceContext.DrawBitmap(Texture.Bitmap, DestinationRectangle, Opacity, SharpDX.Direct2D1.BitmapInterpolationMode.Linear, SourceRectangle);
        }

        /// <summary>
        /// Run our application until the user quits.
        /// </summary>
        public void Draw()
        {
            // Set the Direct2D drawing target.
            SetRenderTarget(m_D2DRenderTarget);

            // Begin the draw sequence.
            BeginDraw();

            // Clear the back buffer.
            Clear(Color.CornflowerBlue);

            // Calculate the center of the screen.
            Int32 HalfWidth = m_DXGISwapChain.Description.ModeDescription.Width / 2;
            Int32 HalfHeight = m_DXGISwapChain.Description.ModeDescription.Height / 2;

            // Translate the origin of coordinates for drawing the bitmap filled rectangle.
            Transform = Matrix3x2.Translation(HalfWidth - 350, HalfHeight);

            // Fills the rectangles with the terrain brush.
            m_D2D1DeviceContext.FillRectangle(new RectangleF(0, 0, 700, 70), m_TerrainBrush);

            // Test opacity with the rendered bitmaps.
            if (AlphaTest > 1.0F)
                AlphaTest = 0.0F;
            else
                AlphaTest = (AlphaTest + 0.01F);

            // Test rotation with rendered bitmaps.
            RotationTest = RotationTest + 0.01F;

            // Translate the position.
            Transform = Matrix3x2.Translation(HalfWidth, HalfHeight - m_PlayerBitmap.Size.Height);

            // Apply a rotation effect.
            Transform = Transform * Matrix3x2.Rotation(RotationTest, new Vector2(HalfWidth + (66 / 2), (HalfHeight - m_PlayerBitmap.Size.Height) + (92 / 2)));

            // Apply a scaling effect.
            Transform = Transform * Matrix3x2.Scaling(0.75F, 0.75F, new Vector2(HalfWidth + (66 / 2), (HalfHeight - m_PlayerBitmap.Size.Height) + (92 / 2)));

            System.Diagnostics.Stopwatch Watch = new System.Diagnostics.Stopwatch();

            // Draw the bitmap.
            Watch.Restart();

            for (Int32 I = 0; I < 5000; I++)
                DrawBitmap(m_PlayerBitmap, AlphaTest);

            Watch.Stop();

            System.Diagnostics.Debug.WriteLine("DrawBitmap: " + Watch.ElapsedMilliseconds +"ms");

            SharpDX.Direct2D1.Effects.Saturation Sat = new SharpDX.Direct2D1.Effects.Saturation(m_D2D1DeviceContext);
            Sat.SetInput(0, m_PlayerBitmap, true);
            Sat.Value = 0F;

            Watch.Restart();

            for (Int32 I = 0; I < 5000; I++)
                m_D2D1DeviceContext.DrawImage(Sat);

            Watch.Stop();

            System.Diagnostics.Debug.WriteLine("DrawImage: " + Watch.ElapsedMilliseconds + "ms");


            Sat.Dispose();

            // End the draw sequence.
            EndDraw();

            // Present the rendered image.
            Present();
        }

        /// <summary>
        /// Dispose all the created objects.
        /// </summary>
        public void Uninitialize()
        {
            Utilities.Dispose(ref m_TerrainBrush);
            Utilities.Dispose(ref m_TerrainBitmap);
            Utilities.Dispose(ref m_PlayerBitmap);
            Utilities.Dispose(ref m_DXGISwapChain);
            Utilities.Dispose(ref m_DXGISurface);
            Utilities.Dispose(ref m_DXGIAdapter);
            Utilities.Dispose(ref m_DXGIDevice);
            Utilities.Dispose(ref m_DXGIFactory);
            Utilities.Dispose(ref m_D2DRenderTarget);
            Utilities.Dispose(ref m_D3D11DeviceContext);
            Utilities.Dispose(ref m_D2D1DeviceContext);
            Utilities.Dispose(ref m_D2D1Device);
            Utilities.Dispose(ref m_D3D11Device);

        }

        /// <summary>
        /// Loads an existing image file into a SharpDX.Direct2D1.Bitmap1.
        /// </summary>
        /// <param name="FileName">The existing image file to load into the bitmap.</param>
        private SharpDX.Direct2D1.Bitmap1 LoadBitmapFromFile(String FileName)
        {
            SharpDX.Direct2D1.Bitmap1 LoadedBitmap;

            // Neccessary for creating WIC objects.
            ImagingFactory ImagingFactory = new ImagingFactory();
            NativeFileStream BitmapFileStream = new NativeFileStream(Environment.CurrentDirectory + FileName, NativeFileMode.Open, NativeFileAccess.Read);

            // Used to read the image source file.
            BitmapDecoder Decoder = new BitmapDecoder(ImagingFactory, BitmapFileStream, DecodeOptions.CacheOnDemand);

            // Convert it to a compatible pixel format.
            FormatConverter Converter = new FormatConverter(ImagingFactory);

            Converter.Initialize(Decoder.GetFrame(0), SharpDX.WIC.PixelFormat.Format32bppPRGBA, BitmapDitherType.None, null, 0.0D, BitmapPaletteType.Custom);

            // Create the new Bitmap1 directly from the FormatConverter.
            LoadedBitmap = SharpDX.Direct2D1.Bitmap1.FromWicBitmap(m_D2D1DeviceContext, Converter);

            Utilities.Dispose(ref Converter);
            Utilities.Dispose(ref Decoder);
            Utilities.Dispose(ref BitmapFileStream);
            Utilities.Dispose(ref ImagingFactory);

            return LoadedBitmap;
        }

        /// <summary>
        /// Gets the Direct2D device.
        /// </summary>
        public SharpDX.Direct2D1.Device D2DDevice
        {
            get
            {
                return m_D2D1Device;
            }
        }

        /// <summary>
        /// Gets the Direct2D device context.
        /// </summary>
        public SharpDX.Direct2D1.DeviceContext D2DDeviceContext
        {
            get
            {
                return m_D2D1DeviceContext;
            }
        }
    }
}
