using System;
using System.Windows.Forms;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using SharpDX.RawInput;
using SharpDX.Multimedia;

namespace Eclipse2D.Input
{
    /// <summary>
    /// Represents a keyboard device.
    /// </summary>
    public static class Keyboard
    {
        /// <summary>
        /// Represents the game window this keyboard is attached to.
        /// </summary>
        private static IntPtr m_WindowHandle;

        /// <summary>
        /// Represents a collection of currently pressed keys.
        /// </summary>
        private static List<Keys> m_KeyboardKeys;

        /// <summary>
        /// Initializes the keyboard.
        /// </summary>
        /// <param name="Window">The handle of the underlying render window.</param>
        public static void Initialize(IntPtr Window)
        {
            // The handle of the underlying render window.
            m_WindowHandle = Window;

            // Initialize the key list.
            m_KeyboardKeys = new List<Keys>(5);

            // Register the keyboard with RawInput, and get keyboard events directed at the target window.
            Device.RegisterDevice(UsagePage.Generic, UsageId.GenericKeyboard, DeviceFlags.None, m_WindowHandle);

            // Hook the keyboard input event.
            Device.KeyboardInput += Device_KeyboardInput;
        }

        /// <summary>
        /// Event: Handles keyboard input events associated with the underlying render window.
        /// </summary>
        private static void Device_KeyboardInput(Object Sender, KeyboardInputEventArgs KeyArgs)
        {
            // Get the window from the handle. 
            Control Window = Control.FromHandle(m_WindowHandle);

            // Checks if the underlying render window has focus. We don't want to handle any input
            // when the associated game window is minimized or doesn't have focus.
            if (Window == null || !Window.Focused)
            {
                return;
            }

            // Checks if the key is down by the user or system.
            if (KeyArgs.State == KeyState.KeyDown || KeyArgs.State == KeyState.SystemKeyDown)
            {
                // Checks if the list already contains this key. We only want to add the key once,
                // because if the key still exists, then the key is being held down.
                if (!m_KeyboardKeys.Contains(KeyArgs.Key))
                {
                    // Add the key to the key list.
                    m_KeyboardKeys.Add(KeyArgs.Key);
                }
            }

            // Checks if the key is up by the user or system.
            if (KeyArgs.State == KeyState.KeyUp || KeyArgs.State == KeyState.SystemKeyUp)
            {
                // Checks if the list contains this key.
                if (m_KeyboardKeys.Contains(KeyArgs.Key))
                {
                    // Remove the key from the key list.
                    m_KeyboardKeys.Remove(KeyArgs.Key);
                }
            }
        }

        /// <summary>
        /// Gets the current keyboard state.
        /// </summary>
        /// <returns></returns>
        public static KeyboardState GetState()
        {
            return new KeyboardState(m_KeyboardKeys);
        }

        /// <summary>
        /// Gets the underlying render window associated with this keyboard.
        /// </summary>
        public static IntPtr WindowHandle
        {
            get
            {
                return m_WindowHandle;
            }
        }
    }
}
